/**
 * ChemTex - Streamlined Chemistry Renderer
 * Detects chem:molecule: syntax and renders 2D structures using SmilesDrawer
 * No 3D viewer, no size controls, no tags - just clean molecule rendering
 */

// ============================================================================
// LOGGING SYSTEM
// ============================================================================

const log = {
  info: (msg) => console.log(`%c[ChemTex] [INFO] ${msg}`, 'color: #2196F3;'),
  success: (msg) => console.log(`%c[ChemTex] [SUCCESS] ${msg}`, 'color: #4CAF50;'),
  error: (msg) => console.log(`%c[ChemTex] [ERROR] ${msg}`, 'color: #F44336;'),
  debug: (msg) => console.log(`%c[ChemTex] [DEBUG] ${msg}`, 'color: #9E9E9E;')
};

log.info('üß™ Content script loaded!');
log.info(`Page URL: ${window.location.href}`);

// Wait for IntegratedSearch to load
if (typeof window.IntegratedSearch === 'undefined') {
  log.info('‚è≥ Waiting for IntegratedSearch module to load...');
  let checkCount = 0;
  const checkInterval = setInterval(() => {
    checkCount++;
    if (typeof window.IntegratedSearch !== 'undefined') {
      log.success('‚úÖ IntegratedSearch module loaded!');
      clearInterval(checkInterval);
    } else if (checkCount > 20) {
      log.error('‚ùå IntegratedSearch module failed to load after 2 seconds');
      clearInterval(checkInterval);
    }
  }, 100);
} else {
  log.success('‚úÖ IntegratedSearch module already loaded!');
}

// ============================================================================
// SETTINGS
// ============================================================================

let settings = {
  enabled: true,
  
  // SmilesDrawer rendering options (synced with popup.html toggles)
  sdShowCarbons: false,
  sdShowHydrogens: false,
  sdAtomNumbers: false,
  sdShowMethyls: false,
  sdAromaticRings: true,
  sdFlipHorizontal: false,
  sdFlipVertical: false
};

// Load settings from Chrome storage
log.info('üì¶ Loading settings from storage...');
chrome.storage.sync.get(null, (items) => {
  if (chrome.runtime.lastError) {
    log.error('Failed to load settings: ' + chrome.runtime.lastError.message);
    // Initialize anyway with defaults
    log.info('üöÄ Using default settings, initializing renderer...');
    initializeRenderer();
  } else {
    // Merge loaded settings
    settings = { ...settings, ...items };
    log.success('‚úÖ Settings loaded');
    log.debug(`Settings: ${JSON.stringify(settings, null, 2)}`);
    
    // Initialize renderer if enabled (default is true)
    if (settings.enabled !== false) {
      log.info('üöÄ Extension enabled, initializing renderer...');
      initializeRenderer();
    } else {
      log.info('‚è∏Ô∏è  Extension disabled in settings');
    }
  }
});

// Listen for settings changes
chrome.storage.onChanged.addListener((changes, namespace) => {
  if (namespace === 'sync') {
    log.info('‚öôÔ∏è  Settings changed, reloading...');
    for (let key in changes) {
      settings[key] = changes[key].newValue;
    }
    
    // Re-scan page if enabled status changed
    if (changes.enabled) {
      if (changes.enabled.newValue) {
        log.info('‚úÖ Extension enabled, scanning page...');
        initializeRenderer();
      } else {
        log.info('‚ùå Extension disabled');
      }
    } else {
      // Just re-scan with new settings
      scanAndRender();
    }
  }
});

// ============================================================================
// SMILES DRAWER RENDERING
// ============================================================================

/**
 * Render a molecule using SmilesDrawer
 * @param {string} smiles - SMILES notation
 * @param {object} options - SmilesDrawer options
 * @returns {Promise<string>} - Base64 SVG data URL
 */
async function renderWithSmilesDrawer(smiles, options = {}) {
  return new Promise((resolve, reject) => {
    try {
      // Check if SmilesDrawer is loaded
      if (typeof SmilesDrawer === 'undefined') {
        reject(new Error('SmilesDrawer library not loaded'));
        return;
      }
      
      log.debug(`Rendering SMILES: ${smiles.substring(0, 50)}...`);
      
      // Build SmilesDrawer options from settings
      const drawerOptions = {
        width: options.width || 400,
        height: options.height || 300,
        bondThickness: 2,
        bondLength: 15,
        shortBondLength: 0.85,
        bondSpacing: 0.18 * 15,
        atomVisualization: 'default',
        isomeric: true,
        debug: false,
        terminalCarbons: settings.sdShowMethyls || settings.sdShowCarbons,
        explicitHydrogens: settings.sdShowHydrogens,
        overlapSensitivity: 0.42,
        overlapResolutionIterations: 1,
        compactDrawing: !settings.sdShowCarbons,
        fontSizeLarge: 6,
        fontSizeSmall: 4,
        padding: 20.0,
        experimental: false,
        themes: {
          dark: {
            C: '#fff',
            O: '#e74c3c',
            N: '#3498db',
            F: '#27ae60',
            CL: '#16a085',
            BR: '#d35400',
            I: '#8e44ad',
            P: '#f39c12',
            S: '#f1c40f',
            B: '#e67e22',
            SI: '#95a5a6',
            H: '#fff',
            BACKGROUND: '#141414'
          },
          light: {
            C: '#222',
            O: '#e74c3c',
            N: '#3498db',
            F: '#27ae60',
            CL: '#16a085',
            BR: '#d35400',
            I: '#8e44ad',
            P: '#f39c12',
            S: '#f1c40f',
            B: '#e67e22',
            SI: '#95a5a6',
            H: '#222',
            BACKGROUND: '#fff'
          }
        },
        
        // Apply user settings from popup
        showCarbons: settings.sdShowCarbons,
        showHydrogens: settings.sdShowHydrogens,
        atomNumbering: settings.sdAtomNumbers,
        showAromaticRings: settings.sdAromaticRings
      };
      
      // Create SmilesDrawer instance
      const drawer = new SmilesDrawer.SvgDrawer(drawerOptions);
      
      log.debug('Parsing SMILES with SmilesDrawer...');
      // Parse SMILES
      SmilesDrawer.parse(smiles, (tree) => {
        try {
          log.debug('SMILES parsed successfully, drawing SVG...');
          
          // Generate unique ID ONCE for this SVG (CRITICAL: must use same ID for draw and getElementById)
          const uniqueId = 'smiles-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
          log.debug(`Drawing to canvas ID: ${uniqueId}`);
          
          // Draw to SVG
          drawer.draw(tree, uniqueId, 'light', false);
          
          // Get SVG element using THE SAME ID
          const svg = document.getElementById(uniqueId);
          if (!svg) {
            log.error(`SVG element not found with ID: ${uniqueId}`);
            reject(new Error('Failed to create SVG'));
            return;
          }
          
          log.debug('SVG element found, applying transformations...');
        
        // Apply flip transformations if needed
        if (settings.sdFlipHorizontal || settings.sdFlipVertical) {
          const scaleX = settings.sdFlipHorizontal ? -1 : 1;
          const scaleY = settings.sdFlipVertical ? -1 : 1;
          const viewBox = svg.getAttribute('viewBox');
          const [x, y, width, height] = viewBox.split(' ').map(Number);
          
          const g = svg.querySelector('g');
          if (g) {
            g.setAttribute('transform', 
              `translate(${scaleX === -1 ? width : 0}, ${scaleY === -1 ? height : 0}) scale(${scaleX}, ${scaleY})`
            );
          }
        }
        
        // Convert to base64
        log.debug('Serializing SVG...');
        const svgData = new XMLSerializer().serializeToString(svg);
        log.debug(`SVG serialized, length: ${svgData.length} characters`);
        
        const base64 = btoa(unescape(encodeURIComponent(svgData)));
        const dataUrl = `data:image/svg+xml;base64,${base64}`;
        log.debug(`Base64 encoded, data URL length: ${dataUrl.length}`);
        
        // Clean up temp element
        svg.remove();
        
        log.info('‚úÖ SmilesDrawer rendering complete');
        resolve(dataUrl);
        
        } catch (drawError) {
          log.error('Error during SVG drawing/serialization:', drawError);
          reject(drawError);
        }
      }, (err) => {
        log.error('SMILES parsing error:', err);
        reject(new Error('SMILES parsing failed: ' + err));
      });
    } catch (error) {
      reject(error);
    }
  });
}

// ============================================================================
// SEARCH API INTEGRATION (Using IntegratedSearch)
// ============================================================================

/**
 * Query databases for molecule data using IntegratedSearch
 * @param {string} query - Molecule name
 * @returns {Promise<object>} - Search result with pdbid, codid, or SMILES
 */
async function querySearchAPI(query) {
  try {
    log.info(`üîç Searching databases: "${query}"`);
    
    // Check if IntegratedSearch is available
    if (typeof window.IntegratedSearch === 'undefined') {
      throw new Error('IntegratedSearch module not loaded');
    }
    
    // Use IntegratedSearch to query RCSB, COD, and PubChem
    const result = await window.IntegratedSearch.search(query);
    
    if (result.error) {
      throw new Error(result.error);
    }
    
    log.success(`‚úÖ Found: ${result.name} (${result.primary_type})`);
    log.debug(`Result details: pdbid=${result.pdbid || 'none'}, codid=${result.codid || 'none'}, cid=${result.cid || 'none'}`);
    
    return result;
  } catch (error) {
    log.error(`‚ùå Search error: ${error.message}`);
    throw error;
  }
}

// ============================================================================
// FORMULA DETECTION & RENDERING
// ============================================================================

/**
 * Detect and wrap chemistry formulas in the page
 */
function scanAndRender() {
  log.info('üîç Scanning page for chemistry formulas...');
  
  // Regex to match chem:NAME: or chem:NAME/flags:
  const chemRegex = /chem:([\w\-]+)(?:\/([^:]*?))?:/gi;
  
  let matchCount = 0;
  let processedNodes = new Set();
  
  // Walk through text nodes
  const walker = document.createTreeWalker(
    document.body,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode: (node) => {
        // Skip if parent is a script, style, or already processed
        const parent = node.parentElement;
        if (!parent || 
            parent.tagName === 'SCRIPT' || 
            parent.tagName === 'STYLE' ||
            parent.classList.contains('chemtex-molecule') ||
            processedNodes.has(node)) {
          return NodeFilter.FILTER_REJECT;
        }
        
        // Only accept if text contains chem:
        if (node.textContent && node.textContent.includes('chem:')) {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_REJECT;
      }
    }
  );
  
  const nodesToProcess = [];
  let node;
  while ((node = walker.nextNode())) {
    nodesToProcess.push(node);
  }
  
  log.debug(`Found ${nodesToProcess.length} text nodes with 'chem:' pattern`);
  
  // Process each text node
  nodesToProcess.forEach(textNode => {
    if (processedNodes.has(textNode)) return;
    
    const text = textNode.textContent;
    const matches = [...text.matchAll(chemRegex)];
    
    if (matches.length === 0) {
      log.debug(`No valid matches in text: "${text.substring(0, 50)}..."`);
      return;
    }
    
    log.debug(`Found ${matches.length} molecule(s) in text node`);
    
    // Create a document fragment to hold the new nodes
    const fragment = document.createDocumentFragment();
    let lastIndex = 0;
    
    matches.forEach(match => {
      const fullMatch = match[0]; // e.g., "chem:caffeine:" or "chem:caffeine/+c:"
      const moleculeName = match[1]; // e.g., "caffeine"
      const flags = match[2] || ''; // e.g., "+c" or ""
      const matchStart = match.index;
      const matchEnd = matchStart + fullMatch.length;
      
      // Add text before the match
      if (matchStart > lastIndex) {
        fragment.appendChild(
          document.createTextNode(text.substring(lastIndex, matchStart))
        );
      }
      
      // Create molecule data object
      const moleculeData = {
        nomenclature: moleculeName,
        name: moleculeName,
        type: 'nomenclature'
      };
      
      // Create IMG placeholder with data attribute (exact same format as old code)
      const img = document.createElement('img');
      img.className = 'chemfig-diagram';
      img.src = '';
      img.alt = 'chem';
      img.dataset.moleculeViewer = btoa(JSON.stringify(moleculeData));
      img.dataset.loaded = 'false';
      img.style.cssText = `
        display: inline-block;
        height: auto;
        margin: 0 12px 8px 0;
        vertical-align: middle;
        padding: 4px;
        border-radius: 4px;
        background-color: transparent;
      `;
      
      // Load molecule asynchronously
      // Add IMG to DOM first, THEN load (like old code)
      fragment.appendChild(img);
      
      // Load after DOM insertion with small delay
      setTimeout(() => {
        loadMoleculeImage(img);
      }, 10);
      
      matchCount++;
      lastIndex = matchEnd;
    });
    
    // Add remaining text after last match
    if (lastIndex < text.length) {
      fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
    }
    
    // Replace the text node with the fragment
    textNode.parentNode.replaceChild(fragment, textNode);
    processedNodes.add(textNode);
  });
  
  log.success(`‚ú® Found and processed ${matchCount} molecule(s)`);
}

/**
 * Load and render a molecule image (matches old content.js.backup pattern)
 * Extracts molecule data from IMG element and renders with SmilesDrawer
 * @param {HTMLImageElement} img - Image element with dataset.moleculeViewer
 */
async function loadMoleculeImage(img) {
  try {
    // Extract molecule data from IMG element (old code pattern)
    const moleculeData = JSON.parse(atob(img.dataset.moleculeViewer || img.dataset.mol2chemfig));
    const moleculeName = moleculeData.nomenclature || moleculeData.name;
    
    log.info(`üì° Loading molecule: ${moleculeName}`);
    
    // Query search API using IntegratedSearch
    const searchResult = await querySearchAPI(moleculeName);
    
    // Log what we got back
    log.debug(`Search result: type=${searchResult.primary_type}, pdbid=${searchResult.pdbid || 'none'}, codid=${searchResult.codid || 'none'}, cid=${searchResult.cid || 'none'}`);
    log.debug(`SMILES data: isomeric=${searchResult.isomeric_smiles ? 'YES' : 'NO'}, canonical=${searchResult.canonical_smiles ? 'YES' : 'NO'}`);
    
    // Get SMILES (prefer isomeric for stereochemistry)
    const smiles = searchResult.isomeric_smiles || searchResult.canonical_smiles;
    
    log.debug(`Extracted SMILES: ${smiles ? smiles.substring(0, 50) : 'NONE'}`);
    
    if (!smiles) {
      throw new Error(`No SMILES data available for ${moleculeName} (type: ${searchResult.primary_type})`);
    }
    
    log.info(`üé® Rendering ${moleculeName} with SMILES: ${smiles.substring(0, 30)}${smiles.length > 30 ? '...' : ''}`);
    
    // Render with SmilesDrawer
    log.debug('Calling renderWithSmilesDrawer...');
    const svgDataUrl = await renderWithSmilesDrawer(smiles);
    log.debug(`Got SVG data URL, length: ${svgDataUrl.length}`);
    
    // Set image source
    log.debug('Setting img.src...');
    img.src = svgDataUrl;
    img.alt = searchResult.name || moleculeName;
    img.title = `${searchResult.name || moleculeName}${searchResult.formula ? ' (' + searchResult.formula + ')' : ''}`;
    img.dataset.loaded = 'true';
    
    log.success(`‚úÖ Successfully rendered ${moleculeName}`);
    
  } catch (error) {
    log.error(`‚ùå Failed to load ${moleculeData.nomenclature || moleculeData.name}: ${error.message}`);
    log.error('Full error:', error);
    log.error('Error stack:', error.stack);
    
    // Show error state
    img.alt = `${moleculeData.nomenclature || moleculeData.name} (failed to load)`;
    img.title = `Error: ${error.message}`;
    img.dataset.loaded = 'error';
    
    // Create simple error SVG
    const errorSvg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="200" height="100">
        <text x="100" y="50" text-anchor="middle" font-family="Arial" font-size="14" fill="#d32f2f">
          ‚ö†Ô∏è ${moleculeData.nomenclature || moleculeData.name}
        </text>
        <text x="100" y="70" text-anchor="middle" font-family="Arial" font-size="10" fill="#666">
          ${error.message}
        </text>
      </svg>
    `;
    const base64 = btoa(errorSvg);
    img.src = `data:image/svg+xml;base64,${base64}`;
  }
}

// ============================================================================
// INITIALIZATION
// ============================================================================

function initializeRenderer() {
  log.info('üîß Initializing chemistry renderer...');
  
  // Mark as initialized
  window.chemtexInitialized = true;
  
  // Check if body exists
  if (!document.body) {
    log.error('‚ùå document.body not found! Waiting for DOM...');
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        log.info('‚úÖ DOM loaded, retrying initialization');
        initializeRenderer();
      });
    }
    return;
  }
  
  // Initial scan
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      scanAndRender();
    });
  } else {
    scanAndRender();
  }
  
  // Watch for dynamic content
  const observer = new MutationObserver((mutations) => {
    let shouldRescan = false;
    
    for (const mutation of mutations) {
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        // Check if any added nodes contain text with chem:
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.TEXT_NODE && node.textContent.includes('chem:')) {
            shouldRescan = true;
            break;
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const textContent = node.textContent || '';
            if (textContent.includes('chem:')) {
              shouldRescan = true;
              break;
            }
          }
        }
      }
      if (shouldRescan) break;
    }
    
    if (shouldRescan) {
      log.info('üîÑ Dynamic content detected, re-scanning...');
      scanAndRender();
    }
  });
  
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  log.success('‚úÖ Renderer initialized');
}

log.info('‚ú® ChemTex content script ready!');

// Fallback initialization in case storage is slow/fails
setTimeout(() => {
  if (!window.chemtexInitialized) {
    log.info('‚ö†Ô∏è  Fallback initialization triggered');
    initializeRenderer();
  }
}, 1000);
