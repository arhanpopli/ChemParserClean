"""
Mol2ChemFig Server - Flask wrapper for mol2chemfig Docker backend
Provides persistent SVG/PDF links and Chrome extension integration

Port: 1000 (Docker backend uses 8000)
"""

from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import requests
import os
import hashlib
import json
from datetime import datetime
from pathlib import Path
import sys
import base64
import tempfile
import subprocess
import shutil
from rdkit import Chem
from rdkit.Chem import AllChem
import re

# Import canonicalization utility
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from canonicalize_smiles import canonicalize_smiles

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', 'chemfig-server-secret-key-change-in-production')
CORS(app, supports_credentials=True)

# Configuration
MOL2CHEMFIG_BACKEND = "http://localhost:8000"  # Docker backend
STORAGE_DIR = Path("cache") / "mol2chemfig"
STORAGE_DIR.mkdir(parents=True, exist_ok=True)

# In-memory cache for quick lookups
image_cache = {}  # key: hash -> {svg: path, pdf: path, chemfig: str, timestamp}


def get_content_hash(smiles, options=None, h2=None):
    """
    Generate unique hash for SMILES + options + h2 combination
    Uses canonical SMILES to prevent duplicates
    """
    canonical = canonicalize_smiles(smiles)
    if canonical is None:
        print(f"Warning: Could not canonicalize SMILES '{smiles}', using original")
        canonical = smiles

    options_str = json.dumps(sorted(options or []))
    h2_str = h2 or 'keep'  # Include h2 parameter in hash
    content = f"{canonical}:{options_str}:{h2_str}"
    return hashlib.sha256(content.encode()).hexdigest()[:16]


def fix_svg_stroke_width(svg_content, new_width='0.8'):
    """
    Fix thin stroke widths in SVG generated by dvisvgm.
    The default 0.3985pt is too thin - increase to match PDF appearance.
    """
    import re
    # Replace thin stroke-width values (handles both single and double quotes)
    fixed = re.sub(
        r"stroke-width=['\"]([0-9.]+)['\"]",
        f"stroke-width='{new_width}'",
        svg_content
    )
    return fixed


def get_pdf_converter():
    """
    Check which PDF to SVG conversion tool is available.
    Returns tuple of (tool_name, tool_path) or (None, None) if none available.
    Prefers pdftocairo over pdf2svg.
    """
    # Check for pdftocairo (from poppler-utils) - preferred
    pdftocairo_path = shutil.which('pdftocairo')
    if pdftocairo_path:
        return ('pdftocairo', pdftocairo_path)

    # Check for pdf2svg as fallback
    pdf2svg_path = shutil.which('pdf2svg')
    if pdf2svg_path:
        return ('pdf2svg', pdf2svg_path)

    return (None, None)


def convert_pdf_to_svg(pdf_base64):
    """
    Convert base64-encoded PDF to SVG.

    Args:
        pdf_base64: Base64 PDF data, either raw base64 or data URL format
                   (e.g., "data:application/pdf;base64,...")

    Returns:
        SVG content as string

    Raises:
        ValueError: If input is invalid or conversion fails
    """
    # Check for available converter
    tool_name, tool_path = get_pdf_converter()
    if tool_name is None:
        raise ValueError("No PDF to SVG converter available. Install poppler-utils (pdftocairo) or pdf2svg.")

    # Extract base64 data from data URL if present
    if pdf_base64.startswith('data:'):
        # Format: data:application/pdf;base64,XXXXXXX
        try:
            # Split on comma to get the base64 part
            header, base64_data = pdf_base64.split(',', 1)
            if 'base64' not in header:
                raise ValueError("Data URL must be base64 encoded")
            pdf_base64 = base64_data
        except ValueError as e:
            raise ValueError(f"Invalid data URL format: {e}")

    # Decode base64 to bytes
    try:
        pdf_bytes = base64.b64decode(pdf_base64)
    except Exception as e:
        raise ValueError(f"Failed to decode base64 PDF: {e}")

    # Verify it looks like a PDF
    if not pdf_bytes.startswith(b'%PDF'):
        raise ValueError("Invalid PDF data: does not start with PDF header")

    # Create temp files for conversion
    temp_dir = tempfile.mkdtemp(prefix='pdf2svg_')
    pdf_path = os.path.join(temp_dir, 'input.pdf')
    svg_path = os.path.join(temp_dir, 'output.svg')

    try:
        # Write PDF to temp file
        with open(pdf_path, 'wb') as f:
            f.write(pdf_bytes)

        # Run conversion
        if tool_name == 'pdftocairo':
            # pdftocairo -svg input.pdf output.svg
            cmd = [tool_path, '-svg', pdf_path, svg_path]
        else:  # pdf2svg
            # pdf2svg input.pdf output.svg
            cmd = [tool_path, pdf_path, svg_path]

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=30
        )

        if result.returncode != 0:
            error_msg = result.stderr or result.stdout or "Unknown error"
            raise ValueError(f"PDF to SVG conversion failed: {error_msg}")

        # Read SVG output
        if not os.path.exists(svg_path):
            raise ValueError("Conversion completed but SVG file was not created")

        with open(svg_path, 'r', encoding='utf-8') as f:
            svg_content = f.read()

        if not svg_content.strip():
            raise ValueError("Conversion produced empty SVG")

        return svg_content

    except subprocess.TimeoutExpired:
        raise ValueError("PDF to SVG conversion timed out")
    except Exception as e:
        if isinstance(e, ValueError):
            raise
        raise ValueError(f"PDF to SVG conversion error: {e}")
    finally:
        # Clean up temp files
        try:
            if os.path.exists(pdf_path):
                os.remove(pdf_path)
            if os.path.exists(svg_path):
                os.remove(svg_path)
            os.rmdir(temp_dir)
        except Exception as cleanup_error:
            print(f"[WARNING] Failed to clean up temp files: {cleanup_error}")


def save_svg_content(svg_content, content_hash):
    """Save SVG content to disk and return the filename"""
    filename = f"{content_hash}.svg"
    filepath = STORAGE_DIR / filename

    # Fix thin stroke widths before saving
    fixed_svg = fix_svg_stroke_width(svg_content)

    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(fixed_svg)

    return filename


@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint"""
    try:
        response = requests.get(f"{MOL2CHEMFIG_BACKEND}/", timeout=2)
        docker_status = "healthy" if response.status_code == 200 else "unhealthy"
    except:
        docker_status = "unreachable"

    return jsonify({
        "status": "running",
        "server": "mol2chemfig_server",
        "port": 1000,
        "docker_backend": docker_status,
        "storage": str(STORAGE_DIR),
        "cached_images": len(image_cache)
    })


@app.route('/images/<filename>', methods=['GET'])
def serve_image(filename):
    """Serve generated SVG/PDF files from cache"""
    try:
        filepath = STORAGE_DIR / filename
        if not filepath.exists():
            return jsonify({"error": "File not found"}), 404

        if filename.endswith('.svg'):
            mimetype = 'image/svg+xml'
        elif filename.endswith('.pdf'):
            mimetype = 'application/pdf'
        else:
            mimetype = 'application/octet-stream'

        return send_file(filepath, mimetype=mimetype)

    except Exception as e:
        return jsonify({"error": str(e)}), 500


# =============================================================================
# MAIN ENDPOINTS - /m2cf/* (used by Chrome extension and web interface)
# =============================================================================

def is_smiles(text):
    """
    Check if text looks like SMILES notation rather than a chemical name.

    Strategy: Check for chemical name patterns FIRST, then SMILES patterns.
    """
    text = text.strip()

    # If it contains spaces, it's likely a chemical name
    if ' ' in text:
        return False

    # Check for chemical name indicators FIRST (before SMILES checks)
    # These suffixes are very common in chemical nomenclature
    name_indicators = ['ine', 'ane', 'ene', 'yne', 'ol', 'al', 'ic', 'ide', 'ate', 'ium', 'ose', 'yl', 'ase']
    text_lower = text.lower()
    if len(text) > 4 and any(text_lower.endswith(indicator) or indicator in text_lower for indicator in name_indicators):
        # Additional check: if it's mostly lowercase letters, it's a name
        lowercase_count = sum(1 for c in text if c.islower())
        if lowercase_count > len(text) * 0.5:
            return False

    # Check for SMILES-specific special characters
    smiles_special_chars = set('=[]()@+#\\/%.')
    if any(c in smiles_special_chars for c in text):
        return True

    # Check if it's purely uppercase letters (simple alkanes like CCCC, CCO)
    # SMILES atoms: C, N, O, S, P, F, I, B, H, Cl, Br
    if text.isupper() and all(c in 'CNOSPFIBH' for c in text):
        return True

    # Check for aromatic SMILES patterns - only if the text is SHORT
    # and has the characteristic pattern of aromatic SMILES (like c1ccccc1)
    # Not just any text containing 'c', 'n', 'o', 's'
    if len(text) <= 20:
        # Aromatic SMILES typically have digits for ring closures
        has_digits = any(c.isdigit() for c in text)
        has_aromatic = any(c in 'cnos' for c in text)
        if has_digits and has_aromatic:
            return True

    # Check for numeric digits (ring closures like C1CCCCC1)
    if any(c.isdigit() for c in text):
        # If it has digits, check if it looks like SMILES structure
        # (mostly uppercase with some digits)
        uppercase_count = sum(1 for c in text if c.isupper())
        if uppercase_count >= len(text) * 0.3:
            return True

    return False


def convert_nomenclature_to_smiles(name):
    """
    Convert chemical name to SMILES using PubChem API.
    Returns (smiles, source) tuple or (None, error_message) on failure.
    """
    try:
        # URL encode the name
        encoded_name = requests.utils.quote(name)
        url = f"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/{encoded_name}/property/CanonicalSMILES/JSON"

        print(f"[SMILES] Converting '{name}' via PubChem...")
        response = requests.get(url, timeout=15)

        if response.status_code == 404:
            print(f"[SMILES] '{name}' not found in PubChem")
            return None, f"Compound '{name}' not found in PubChem"

        if response.status_code != 200:
            print(f"[SMILES] PubChem returned status {response.status_code}")
            return None, f"PubChem API error: {response.status_code}"

        try:
            data = response.json()
        except:
            return None, "PubChem returned invalid JSON"

        # Extract SMILES from response - try multiple field names
        if 'PropertyTable' in data and 'Properties' in data['PropertyTable']:
            props = data['PropertyTable']['Properties']
            if len(props) > 0:
                # PubChem returns different SMILES field names depending on the query
                smiles = (props[0].get('CanonicalSMILES') or
                         props[0].get('ConnectivitySMILES') or
                         props[0].get('IsomericSMILES'))
                if smiles:
                    print(f"[SMILES] Converted '{name}' -> '{smiles}'")
                    return smiles, 'PubChem'

        return None, f"Could not extract SMILES for '{name}'"

    except requests.exceptions.Timeout:
        return None, "PubChem API timeout"
    except requests.exceptions.ConnectionError:
        return None, "Cannot connect to PubChem API"
    except Exception as e:
        return None, f"SMILES conversion error: {str(e)}"



def get_cid_from_name(name):
    """
    Get PubChem CID from name.
    Returns CID (int) or None.
    """
    try:
        encoded_name = requests.utils.quote(name)
        url = f"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/{encoded_name}/cids/JSON"
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            try:
                data = response.json()
                if 'IdentifierList' in data and 'CID' in data['IdentifierList']:
                    return data['IdentifierList']['CID'][0]
            except:
                pass
        return None
    except:
        return None


def get_smiles_from_cod(codid):
    """
    Get SMILES from COD ID using MolView's proxy or COD directly.
    MolView uses: http://molview.org/php/cod.php?action=smiles&q={codid}
    """
    try:
        # Try MolView API first as it's what the user referenced
        url = f"http://molview.org/php/cod.php?action=smiles&q={codid}"
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            try:
                data = response.json()
                # Format: {"records":[{"id":"9000126","smiles":"[O-][U](=[O+])([O-])=O.[Cu+2].O.O"}]}
                if 'records' in data and len(data['records']) > 0:
                    smiles = data['records'][0].get('smiles')
                    if smiles:
                        return smiles
            except Exception as e:
                print(f"[COD] MolView API returned invalid JSON: {e}")
        
        # Fallback: Scrape COD website directly
        # Example: http://www.crystallography.net/cod/9012360.html
        print(f"[COD] MolView API failed, scraping COD website for {codid}...")
        url = f"http://www.crystallography.net/cod/{codid}.html"
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            html = response.text
            # Look for SMILES in table cell
            # <th>SMILES</th><td>...</td>
            match = re.search(r'SMILES</th>\s*<td>\s*(.*?)\s*</td>', html, re.IGNORECASE | re.DOTALL)
            if match:
                smiles = match.group(1).strip()
                # Remove any HTML tags
                smiles = re.sub(r'<[^>]+>', '', smiles)
                print(f"[COD] Scraped SMILES: {smiles}")
                return smiles
                
        return None
    except Exception as e:
        print(f"[COD] Error fetching SMILES: {e}")
        return None


def add_hydrogens_to_structure(text_data):
    """
    Add explicit hydrogens to a SMILES string or MOL block using RDKit.
    Returns the new structure (SMILES or MOL block).
    """
    try:
        # Check if it's a MOL block
        if "M  END" in text_data or "V2000" in text_data:
            mol = Chem.MolFromMolBlock(text_data)
            is_mol_block = True
        else:
            mol = Chem.MolFromSmiles(text_data)
            is_mol_block = False
            
        if mol is None:
            print(f"[ADD_H] Failed to parse structure: {text_data[:20]}...")
            return text_data
            
        # Add hydrogens
        mol_h = Chem.AddHs(mol)
        
        # Generate 2D coords if needed (usually good for chemfig)
        AllChem.Compute2DCoords(mol_h)
        
        if is_mol_block:
            return Chem.MolToMolBlock(mol_h)
        else:
            # Return isomeric SMILES to preserve stereochemistry if any
            return Chem.MolToSmiles(mol_h, isomericSmiles=True, allHsExplicit=True)
            
    except Exception as e:
        print(f"[ADD_H] Error adding hydrogens: {e}")
        return text_data


@app.route('/m2cf/submit', methods=['POST'])
def m2cf_submit():
    """
    Process SMILES/MOL/Nomenclature to chemfig + SVG via Docker backend

    If input is a chemical name (not SMILES), converts it to SMILES first using PubChem.

    Docker returns:
    - svglink: Contains INLINE SVG content (starts with <?xml)
    - pdflink: Contains base64 PDF

    We save the inline SVG to cache and return a URL path
    """
    try:
        data = request.get_json()
        text_area_data = data.get('textAreaData', '').strip()

        if not text_area_data:
            return jsonify({"error": "No input data provided"}), 400

        print(f"[MOL2CHEMFIG] Processing: {text_area_data[:50]}...")

        # Check if input is a MOL block
        is_mol_block = "M  END" in text_area_data or "V2000" in text_area_data

        # Check if input is nomenclature (not SMILES) and convert it
        original_input = text_area_data
        if not is_mol_block and not is_smiles(text_area_data):
            print(f"[MOL2CHEMFIG] Input looks like nomenclature, converting to SMILES...")
            smiles, source = convert_nomenclature_to_smiles(text_area_data)
            if smiles:
                print(f"[MOL2CHEMFIG] Using SMILES: {smiles} (from {source})")
                text_area_data = smiles
                data['textAreaData'] = smiles
            else:
                # Conversion failed
                return jsonify({"error": source}), 400

        # Handle 'h2' option
        # We rely on Docker to generate the PDF with hydrogens (using -h option)
        # But Docker often fails to generate the SVG correctly with hydrogens.
        # So we will force PDF-to-SVG conversion if h2 is enabled.
        h2_option = data.get('h2', 'keep')
        original_h2 = h2_option  # Store original value for hash calculation
        h2_enabled = h2_option in ['on', 'add']
        
        if h2_enabled:
            print(f"[MOL2CHEMFIG] H2 enabled ({h2_option}), will force PDF-to-SVG conversion...")

        # Call Docker backend
        print(f"[DEBUG] Sending to Docker: textAreaData={data.get('textAreaData')}, h2={data.get('h2')}")
        response = requests.post(f"{MOL2CHEMFIG_BACKEND}/m2cf/submit", json=data, timeout=30)

        if response.status_code != 200:
            print(f"[ERROR] Docker backend failed: {response.status_code} - {response.text}")
            return jsonify({"error": f"Docker backend returned status {response.status_code}: {response.text}"}), 500

        result = response.json()
        print(f"[DEBUG] Docker Response: chem_data={result.get('chem_data')}, svglink={result.get('svglink') is not None}, pdflink={result.get('pdflink') is not None}")

        if result.get('error'):
            return jsonify({"error": result['error']}), 400

        # Docker returns inline SVG in svglink - save it to cache
        # BUT if we enabled hydrogens, we ignore the Docker SVG because it often lacks the hydrogens
        # and prefer to convert the PDF (which usually has them) to SVG ourselves.
        if result.get('svglink') and result['svglink'].startswith('<?xml') and not h2_enabled:
            svg_content = result['svglink']
            content_hash = get_content_hash(text_area_data, data.get('selections', []), original_h2)
            print(f"[DEBUG] Hash calculation: SMILES={text_area_data}, selections={data.get('selections', [])}, h2={original_h2}, hash={content_hash}")

            # Save SVG to cache
            filename = save_svg_content(svg_content, content_hash)

            # Update svglink to point to our cached file URL
            result['svglink'] = f"/images/{filename}"

            # Cache the result
            image_cache[content_hash] = {
                "svg": str(STORAGE_DIR / filename),
                "chemfig": result.get('chemfig', ''),
                "timestamp": datetime.now().isoformat()
            }

            print(f"[DOCKER] Saved SVG to cache: {filename}")
        
        # Fallback: If we enabled hydrogens and Docker didn't return SVG (or we ignored it), convert PDF to SVG
        elif h2_enabled and result.get('pdflink'):
            print("[MOL2CHEMFIG] Docker backend didn't return SVG with hydrogens, converting PDF to SVG locally...")
            try:
                svg_content = convert_pdf_to_svg(result['pdflink'])
                content_hash = get_content_hash(text_area_data, data.get('selections', []), original_h2)
                
                filename = save_svg_content(svg_content, content_hash)
                result['svglink'] = f"/images/{filename}"
                
                image_cache[content_hash] = {
                    "svg": str(STORAGE_DIR / filename),
                    "chemfig": result.get('chemfig', ''),
                    "timestamp": datetime.now().isoformat()
                }
                print(f"[MOL2CHEMFIG] Converted PDF to SVG successfully: {filename}")
            except Exception as e:
                print(f"[ERROR] PDF to SVG conversion failed: {e}")
                # Don't fail the request, PDF is still available
        
        # Fallback: If no SVG but we have PDF, convert it (general case)
        elif result.get('pdflink') and not result.get('svglink'):
            print("[DOCKER] No SVG returned, converting PDF to SVG...")
            try:
                svg_content = convert_pdf_to_svg(result['pdflink'])
                content_hash = get_content_hash(text_area_data, data.get('selections', []), original_h2)
                
                filename = save_svg_content(svg_content, content_hash)
                result['svglink'] = f"/images/{filename}"
                
                image_cache[content_hash] = {
                    "svg": str(STORAGE_DIR / filename),
                    "chemfig": result.get('chemfig', ''),
                    "timestamp": datetime.now().isoformat()
                }
                print(f"[DOCKER] Converted PDF to SVG: {filename}")
            except Exception as e:
                print(f"[ERROR] PDF conversion failed: {e}")
                # Don't fail the request, just don't have SVG

        # pdflink stays as-is (base64)
        return jsonify(result)

    except requests.exceptions.Timeout:
        return jsonify({"error": "Docker backend timeout"}), 504
    except requests.exceptions.ConnectionError:
        return jsonify({"error": "Cannot connect to Docker backend. Is it running?"}), 503
    except Exception as e:
        print(f"[ERROR] {e}")
        return jsonify({"error": str(e)}), 500


@app.route('/api/opsin', methods=['GET'])
def api_opsin():
    """
    Fetch SMILES from Opsin API (supports stereochemistry).
    """
    name = request.args.get('name', '').strip()
    if not name:
        return jsonify({"error": "No name provided"}), 400

    try:
        # Opsin API URL
        url = f"https://opsin.ch.cam.ac.uk/opsin/{requests.utils.quote(name)}.smi"
        print(f"[OPSIN] Fetching: {name}")
        
        response = requests.get(url, timeout=10)
        
        if response.status_code == 200:
            smiles = response.text.strip()
            return jsonify({
                "smiles": smiles,
                "smiles_3d": smiles, # Opsin provides isomeric SMILES by default
                "source": "OPSIN"
            })
        elif response.status_code == 404:
            return jsonify({"error": "Compound not found in Opsin"}), 404
        else:
            return jsonify({"error": f"Opsin API error: {response.status_code}"}), 502
            
    except Exception as e:
        print(f"[ERROR] Opsin API: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/m2cf/opsin-3d', methods=['GET'])
def m2cf_opsin_3d():
    """Alias for /api/opsin to support test_opsin_3d.html"""
    return api_opsin()


@app.route('/m2cf/search', methods=['GET', 'POST'])
def m2cf_search():
    """
    Search for molecule by name - first tries PubChem conversion, then Docker backend
    Enhanced to handle Minerals (COD) and Biomolecules (PDB) with 2D image generation.
    """
    try:
        if request.method == 'GET':
            search_term = request.args.get('searchTerm', '').strip()
        else:
            data = request.get_json()
            search_term = data.get('searchTerm', '').strip()

        if not search_term:
            resp = jsonify({"error": "No search term provided"})
            resp.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
            return resp, 400

        print(f"[SEARCH] Searching: {search_term}")

        # Step 1: If input looks like nomenclature (not SMILES), convert via PubChem first
        # This handles standard compounds efficiently
        if not is_smiles(search_term):
            print(f"[SEARCH] Input looks like nomenclature, trying PubChem conversion...")
            smiles, source = convert_nomenclature_to_smiles(search_term)
            if smiles:
                print(f"[SEARCH] PubChem found: {smiles}")
                resp = jsonify({
                    "smiles": smiles,
                    "source": source,
                    "name": search_term,
                    "compoundType": "compound"
                })
                resp.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
                return resp
            else:
                print(f"[SEARCH] PubChem failed: {source}")
                # Fall through to try Docker backend as backup (might be mineral or protein)

        # Step 2: Try Docker backend (MolView Search)
        print(f"[SEARCH] Trying Docker backend...")
        try:
            if request.method == 'GET':
                response = requests.get(
                    f"{MOL2CHEMFIG_BACKEND}/m2cf/search",
                    params={"searchTerm": search_term},
                    timeout=30
                )
            else:
                response = requests.post(
                    f"{MOL2CHEMFIG_BACKEND}/m2cf/search",
                    json={"searchTerm": search_term},
                    timeout=30
                )

            if response.status_code == 200:
                try:
                    result = response.json()
                except Exception as e:
                    print(f"[SEARCH] Docker backend returned invalid JSON: {e}")
                    # Try to see if it's HTML
                    print(f"[SEARCH] Response start: {response.text[:100]}")
                    return jsonify({"error": "Docker backend returned invalid response"}), 502
                
                # ENHANCEMENT: Handle Biomolecules (PDB)
                if result.get('pdbid'):
                    pdbid = result['pdbid']
                    print(f"[SEARCH] Found Biomolecule: {pdbid}")
                    return jsonify({
                        "pdbid": pdbid,
                        "name": result.get('name', search_term),
                        "compoundType": "biomolecule",
                        # Use RCSB static image as "2D" view
                        "image_url": f"https://cdn.rcsb.org/images/structures/{pdbid}_assembly-1.jpeg",
                        "embed_url": f"http://localhost:8000/embed/v2/?pdbid={pdbid}"
                    })

                # ENHANCEMENT: Handle Minerals (COD)
                if result.get('codid'):
                    codid = result['codid']
                    mineral_name = result.get('name', search_term)
                    print(f"[SEARCH] Found Mineral: {codid} ({mineral_name})")
                    
                    # Strategy 1: Try to get PubChem CID from name -> 2D Image
                    image_url = None
                    cid = get_cid_from_name(mineral_name)
                    
                    if cid:
                        print(f"[SEARCH] Mineral mapped to PubChem CID: {cid}")
                        # Use PubChem image service
                        image_url = f"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/{cid}/PNG?image_size=large"
                    else:
                        print(f"[SEARCH] Mineral name lookup failed, trying COD SMILES...")
                        # Strategy 2: Try to get SMILES from COD -> Generate Image URL
                        smiles = get_smiles_from_cod(codid)
                        if smiles:
                            print(f"[SEARCH] Found SMILES for mineral: {smiles}")
                            # Use our own SMILES rendering endpoint (MoleculeViewer on port 5000)
                            encoded_smiles = requests.utils.quote(smiles)
                            image_url = f"http://localhost:5000/img/smiles?smiles={encoded_smiles}&width=300&height=250"
                            
                            # INJECT SMILES INTO RESULT
                            result['smiles'] = smiles
                            result['canonical_smiles'] = smiles
                            result['isomeric_smiles'] = smiles # Assuming COD provides good SMILES
                        else:
                            print(f"[SEARCH] No 2D representation found for mineral")

                    # Merge with original result to keep SDF, formula, etc.
                    response_data = result.copy()
                    update_dict = {
                        "compoundType": "mineral",
                        "embed_url": f"http://localhost:8000/embed/v2/?codid={codid}"
                    }
                    if image_url:
                        update_dict["image_url"] = image_url
                        
                    response_data.update(update_dict)
                    return jsonify(response_data)

                # Default: Compound/SMILES from Docker
                # If Docker returned inline SVG, save it to cache (existing logic)
                if result.get('svglink') and result['svglink'].startswith('<?xml'):
                    svg_content = result['svglink']
                    smiles = result.get('smiles', search_term)
                    content_hash = get_content_hash(smiles, [], 'keep')

                    filename = save_svg_content(svg_content, content_hash)
                    result['svglink'] = f"/images/{filename}"

                    image_cache[content_hash] = {
                        "svg": str(STORAGE_DIR / filename),
                        "chemfig": result.get('chemfig', ''),
                        "timestamp": datetime.now().isoformat()
                    }
                    print(f"[DOCKER] Saved search result SVG: {filename}")

                result['compoundType'] = 'compound' # Explicitly mark as compound
                return jsonify(result)
            else:
                # Docker failed too
                return jsonify({"error": f"Compound '{search_term}' not found in PubChem or Docker backend"}), 404

        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError) as docker_error:
            # Docker backend unavailable - return PubChem error if we have one
            return jsonify({"error": f"Compound '{search_term}' not found in PubChem (Docker backend unavailable)"}), 404

    except Exception as e:
        print(f"[ERROR] {e}")
        return jsonify({"error": str(e)}), 500


@app.route('/m2cf/apply', methods=['POST'])
def m2cf_apply():
    """Apply chemfig options via Docker backend"""
    try:
        data = request.get_json()

        # Handle 'h2' option
        h2_option = data.get('h2', 'keep')
        original_h2 = h2_option  # Store original value for hash calculation
        h2_enabled = h2_option in ['on', 'add']
        
        if h2_enabled:
            print(f"[MOL2CHEMFIG] H2 enabled ({h2_option}) in Apply, will force PDF-to-SVG conversion...")

        print(f"[DOCKER] Applying options...")
        response = requests.post(f"{MOL2CHEMFIG_BACKEND}/m2cf/apply", json=data, timeout=30)

        if response.status_code != 200:
            return jsonify({"error": f"Docker backend returned status {response.status_code}"}), 500

        result = response.json()

        # If Docker returned inline SVG, save it to cache
        if result.get('svglink') and result['svglink'].startswith('<?xml') and not h2_enabled:
            svg_content = result['svglink']
            chem_data = data.get('chem_data', '')
            selections = data.get('selections', [])
            content_hash = get_content_hash(chem_data, selections, original_h2)

            filename = save_svg_content(svg_content, content_hash)
            result['svglink'] = f"/images/{filename}"

            print(f"[DOCKER] Saved apply result SVG: {filename}")
        
        # Fallback: If we enabled hydrogens and Docker didn't return SVG (or we ignored it), convert PDF to SVG
        elif h2_enabled and result.get('pdflink'):
            print("[MOL2CHEMFIG] Docker backend didn't return SVG with hydrogens (Apply), converting PDF to SVG locally...")
            try:
                svg_content = convert_pdf_to_svg(result['pdflink'])
                chem_data = data.get('chem_data', '')
                selections = data.get('selections', [])
                content_hash = get_content_hash(chem_data, selections, original_h2)
                
                filename = save_svg_content(svg_content, content_hash)
                result['svglink'] = f"/images/{filename}"
                
                image_cache[content_hash] = {
                    "svg": str(STORAGE_DIR / filename),
                    "chemfig": result.get('chemfig', ''),
                    "timestamp": datetime.now().isoformat()
                }
                print(f"[MOL2CHEMFIG] Converted PDF to SVG successfully (Apply): {filename}")
            except Exception as e:
                print(f"[ERROR] PDF to SVG conversion failed (Apply): {e}")
                # Don't fail the request, PDF is still available

        return jsonify(result)

    except requests.exceptions.Timeout:
        return jsonify({"error": "Docker backend timeout"}), 504
    except requests.exceptions.ConnectionError:
        return jsonify({"error": "Cannot connect to Docker backend. Is it running?"}), 503
    except Exception as e:
        print(f"[ERROR] {e}")
        return jsonify({"error": str(e)}), 500


@app.route('/m2cf/reset', methods=['POST'])
def m2cf_reset():
    """Reset session via Docker backend"""
    try:
        response = requests.post(f"{MOL2CHEMFIG_BACKEND}/m2cf/reset", json={}, timeout=10)
        return response.content, response.status_code, {'Content-Type': 'application/json'}
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/m2cf/layers', methods=['POST'])
def m2cf_layers():
    """Generate layered SVGs via Docker backend"""
    try:
        data = request.get_json()
        response = requests.post(f"{MOL2CHEMFIG_BACKEND}/m2cf/layers", json=data, timeout=30)
        return response.content, response.status_code, {'Content-Type': 'application/json'}
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/m2cf/pdf2svg', methods=['POST'])
def m2cf_pdf2svg():
    """
    Convert base64 PDF to SVG.

    Expects JSON body with:
    - pdflink: Base64 PDF data (e.g., "data:application/pdf;base64,...")

    Returns:
    - svg: The converted SVG content
    - tool: Which conversion tool was used (pdftocairo or pdf2svg)
    """
    try:
        data = request.get_json()

        if not data:
            return jsonify({"error": "No JSON data provided"}), 400

        pdf_link = data.get('pdflink')
        if not pdf_link:
            return jsonify({"error": "No pdflink provided in request"}), 400

        print(f"[PDF2SVG] Converting PDF to SVG...")

        # Check which tool is available
        tool_name, tool_path = get_pdf_converter()
        if tool_name is None:
            return jsonify({
                "error": "No PDF to SVG converter available. Install poppler-utils (pdftocairo) or pdf2svg."
            }), 503

        # Convert PDF to SVG
        svg_content = convert_pdf_to_svg(pdf_link)

        # Optionally fix stroke widths
        svg_content = fix_svg_stroke_width(svg_content)

        print(f"[PDF2SVG] Conversion successful using {tool_name}")

        return jsonify({
            "svg": svg_content,
            "tool": tool_name,
            "success": True
        })

    except ValueError as e:
        print(f"[PDF2SVG] Conversion error: {e}")
        return jsonify({"error": str(e), "success": False}), 400
    except Exception as e:
        print(f"[PDF2SVG] Unexpected error: {e}")
        return jsonify({"error": str(e), "success": False}), 500


@app.route('/m2cf/reaction/update_chemfig', methods=['POST'])
def m2cf_reaction_update():
    """Update reaction chemfig via Docker backend"""
    try:
        data = request.get_json()
        response = requests.post(f"{MOL2CHEMFIG_BACKEND}/m2cf/reaction/update_chemfig", json=data, timeout=30)
        return response.content, response.status_code, {'Content-Type': 'application/json'}
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/m2cf/<path:subpath>', methods=['GET', 'POST'])
def m2cf_generic_proxy(subpath):
    """Proxy any other /m2cf/* requests to Docker backend"""
    try:
        url = f"{MOL2CHEMFIG_BACKEND}/m2cf/{subpath}"
        if request.method == 'GET':
            response = requests.get(url, params=request.args, timeout=30)
        else:
            response = requests.post(url, json=request.get_json(), timeout=30)
        return response.content, response.status_code, {'Content-Type': response.headers.get('Content-Type', 'application/json')}
    except Exception as e:
        return jsonify({"error": str(e)}), 500


# =============================================================================
# NOMENCLATURE TO SMILES CONVERSION
# =============================================================================

@app.route('/api/nomenclature-to-smiles', methods=['POST'])
def nomenclature_to_smiles():
    """
    Convert chemical name (nomenclature) to SMILES using PubChem API.

    Expects JSON body with:
    - nomenclature: Chemical name (e.g., "histamine", "caffeine", "butanol")

    Returns:
    - success: true/false
    - smiles: The canonical SMILES string (on success)
    - source: "PubChem" (on success)
    - error: Error message (on failure)
    """
    try:
        data = request.get_json()

        if not data:
            return jsonify({
                "success": False,
                "error": "No JSON data provided"
            }), 400

        nomenclature = data.get('nomenclature', '').strip()

        if not nomenclature:
            return jsonify({
                "success": False,
                "error": "No nomenclature provided"
            }), 400

        print(f"[PUBCHEM] Converting nomenclature to SMILES: {nomenclature}")

        # Call PubChem API to get canonical SMILES
        pubchem_url = f"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/{requests.utils.quote(nomenclature)}/property/CanonicalSMILES/JSON"

        response = requests.get(pubchem_url, timeout=15)

        if response.status_code == 404:
            return jsonify({
                "success": False,
                "error": f"Compound '{nomenclature}' not found in PubChem"
            }), 404

        if response.status_code != 200:
            return jsonify({
                "success": False,
                "error": f"PubChem API returned status {response.status_code}"
            }), 502

        result = response.json()

        # Extract SMILES from PubChem response
        # Response format: {"PropertyTable": {"Properties": [{"CID": 123, "CanonicalSMILES": "..."}]}}
        properties = result.get('PropertyTable', {}).get('Properties', [])

        if not properties:
            return jsonify({
                "success": False,
                "error": f"No SMILES data found for '{nomenclature}'"
            }), 404

        smiles = properties[0].get('CanonicalSMILES')

        if not smiles:
            return jsonify({
                "success": False,
                "error": f"SMILES not available for '{nomenclature}'"
            }), 404

        print(f"[PUBCHEM] Converted '{nomenclature}' -> '{smiles}'")

        return jsonify({
            "success": True,
            "smiles": smiles,
            "source": "PubChem"
        })

    except requests.exceptions.Timeout:
        return jsonify({
            "success": False,
            "error": "PubChem API timeout"
        }), 504
    except requests.exceptions.ConnectionError:
        return jsonify({
            "success": False,
            "error": "Cannot connect to PubChem API"
        }), 503
    except Exception as e:
        print(f"[ERROR] nomenclature_to_smiles: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500


# =============================================================================
# CACHE MANAGEMENT
# =============================================================================

@app.route('/api/cache/clear', methods=['POST'])
def clear_cache():
    """Clear the image cache"""
    try:
        image_cache.clear()
        return jsonify({
            "success": True,
            "message": "Cache cleared",
            "timestamp": datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route('/api/cache/stats', methods=['GET'])
def cache_stats():
    """Get cache statistics"""
    total_files = len(list(STORAGE_DIR.glob('*')))
    total_size = sum(f.stat().st_size for f in STORAGE_DIR.glob('*'))

    return jsonify({
        "cached_entries": len(image_cache),
        "total_files": total_files,
        "storage_size_mb": round(total_size / (1024 * 1024), 2),
        "storage_path": str(STORAGE_DIR)
    })


# =============================================================================
# INDEX / INFO
# =============================================================================

@app.route('/', methods=['GET'])
def index():
    """Serve info or test HTML file"""
    try:
        html_file = Path("test_m2cf_full.html")
        if html_file.exists():
            with open(html_file, 'r', encoding='utf-8') as f:
                return f.read(), 200, {'Content-Type': 'text/html'}
        else:
            # Check PDF converter availability for status
            tool_name, tool_path = get_pdf_converter()
            pdf_converter_status = f"{tool_name} ({tool_path})" if tool_name else "Not available"

            return jsonify({
                "name": "Mol2ChemFig Server",
                "version": "2.0.0",
                "description": "Flask wrapper for mol2chemfig Docker backend",
                "port": 5001,
                "docker_backend": MOL2CHEMFIG_BACKEND,
                "pdf_converter": pdf_converter_status,
                "endpoints": {
                    "health": "/health",
                    "submit": "/m2cf/submit (POST)",
                    "search": "/m2cf/search (GET/POST)",
                    "apply": "/m2cf/apply (POST)",
                    "pdf2svg": "/m2cf/pdf2svg (POST)",
                    "nomenclature_to_smiles": "/api/nomenclature-to-smiles (POST)",
                    "images": "/images/<filename>",
                    "cache_stats": "/api/cache/stats",
                    "cache_clear": "/api/cache/clear (POST)"
                }
            })
    except Exception as e:
        return jsonify({"error": str(e)}), 500


if __name__ == '__main__':
    print("=" * 70)
    print("Mol2ChemFig Server Starting...")
    print("=" * 70)
    print(f"Port: 5001")
    print(f"Docker Backend: {MOL2CHEMFIG_BACKEND}")
    print(f"Storage: {STORAGE_DIR.absolute()}")

    # Check PDF converter availability
    tool_name, tool_path = get_pdf_converter()
    if tool_name:
        print(f"PDF Converter: {tool_name} ({tool_path})")
    else:
        print("PDF Converter: Not available (install poppler-utils or pdf2svg)")

    print("=" * 70)
    print("\nEndpoints:")
    print("  GET  /health                     - Health check")
    print("  POST /m2cf/submit                - Generate from SMILES")
    print("  GET  /m2cf/search                - Search by name")
    print("  POST /m2cf/apply                 - Apply chemfig options")
    print("  POST /m2cf/pdf2svg               - Convert PDF to SVG")
    print("  POST /api/nomenclature-to-smiles - Convert name to SMILES")
    print("  GET  /images/<file>              - Serve generated images")
    print("=" * 70)

    app.run(host='0.0.0.0', port=1000, debug=True)
