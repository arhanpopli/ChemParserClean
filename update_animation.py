import json
import os

# Read the generated SVGs
with open('generated_molecules.json', 'r') as f:
    molecule_data = json.load(f)

# Read the existing JS file to keep the header/structure if needed, 
# but we are rewriting most of it.
# Let's just write the new content directly.

js_content = """/**
 * Bouncing Molecule Animation for Chemistry Renderer Popup
 * Uses real molecule SVGs generated by RDKit
 * Renderer-aware: Shows different style based on selected renderer
 * All molecules normalized to consistent bond lengths (~30px per Angstrom)
 */

(function() {
  var container = document.getElementById('moleculeContainer');
  if (!container) return;

  var WIDTH = 400;
  var HEIGHT = 650;

  // Molecule Data (Injected)
  var moleculeData = %s;

  // Physics constants
  var RESTITUTION = 0.85;
  var MIN_SPEED = 0.25;
  var MAX_SPEED = 0.6;

  // Global state
  var molecules = [];
  var animationId = null;

  // Molecule class
  function Molecule(type, svgString, x, y) {
    this.type = type;
    this.element = document.createElement('div');
    this.element.className = 'floating-molecule';
    this.element.style.cssText = 'position: absolute; pointer-events: none; will-change: transform; transform-origin: center center;';
    this.element.innerHTML = svgString;
    container.appendChild(this.element);

    // Extract dimensions from SVG
    // The generated SVGs have width/height attributes corresponding to physical size
    var svg = this.element.querySelector('svg');
    var width = 60;
    var height = 60;
    
    if (svg) {
      var wAttr = svg.getAttribute('width');
      var hAttr = svg.getAttribute('height');
      if (wAttr) width = parseFloat(wAttr);
      if (hAttr) height = parseFloat(hAttr);
      
      // Apply a global scale factor to fit the popup better if needed
      // The generated SVGs are quite large (e.g. 300px for large molecules)
      // We scale them down slightly to fit more in the popup
      var globalScale = 0.6; 
      width *= globalScale;
      height *= globalScale;
      
      svg.style.width = width + 'px';
      svg.style.height = height + 'px';
    }

    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;

    var angle = Math.random() * Math.PI * 2;
    var speed = MIN_SPEED + Math.random() * (MAX_SPEED - MIN_SPEED);
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;

    this.rotation = Math.random() * 360;
    this.rotationSpeed = (Math.random() - 0.5) * 0.8;
    this.opacity = 0.25 + Math.random() * 0.15;
    this.mass = (this.width * this.height) / 1000; // Mass proportional to area

    this.updatePosition();
  }

  Molecule.prototype.updatePosition = function() {
    this.element.style.transform = 'translate(' + this.x + 'px, ' + this.y + 'px) rotate(' + this.rotation + 'deg)';
    this.element.style.opacity = this.opacity;
  };

  Molecule.prototype.update = function() {
    this.x += this.vx;
    this.y += this.vy;
    this.rotation += this.rotationSpeed;

    var margin = 2;
    if (this.x < margin) {
      this.x = margin;
      this.vx = Math.abs(this.vx) * RESTITUTION;
      this.rotationSpeed *= -0.7;
    } else if (this.x > WIDTH - this.width - margin) {
      this.x = WIDTH - this.width - margin;
      this.vx = -Math.abs(this.vx) * RESTITUTION;
      this.rotationSpeed *= -0.7;
    }

    if (this.y < margin) {
      this.y = margin;
      this.vy = Math.abs(this.vy) * RESTITUTION;
      this.rotationSpeed *= -0.7;
    } else if (this.y > HEIGHT - this.height - margin) {
      this.y = HEIGHT - this.height - margin;
      this.vy = -Math.abs(this.vy) * RESTITUTION;
      this.rotationSpeed *= -0.7;
    }

    this.updatePosition();
  };

  Molecule.prototype.getCenterX = function() {
    return this.x + this.width / 2;
  };

  Molecule.prototype.getCenterY = function() {
    return this.y + this.height / 2;
  };

  Molecule.prototype.distanceTo = function(other) {
    var dx = this.getCenterX() - other.getCenterX();
    var dy = this.getCenterY() - other.getCenterY();
    return Math.sqrt(dx * dx + dy * dy);
  };

  Molecule.prototype.collidesWith = function(other) {
    var dist = this.distanceTo(other);
    var avgSize = (this.width + this.height + other.width + other.height) / 4;
    // Simple circle collision approximation
    return dist < avgSize * 0.7; 
  };

  Molecule.prototype.handleCollision = function(other) {
    var dx = this.getCenterX() - other.getCenterX();
    var dy = this.getCenterY() - other.getCenterY();
    var dist = Math.sqrt(dx * dx + dy * dy);

    if (dist === 0) { dx = 1; dy = 0; dist = 1; }

    var nx = dx / dist;
    var ny = dy / dist;

    var dvx = this.vx - other.vx;
    var dvy = this.vy - other.vy;
    var dvn = dvx * nx + dvy * ny;

    if (dvn > 0) return;

    var totalMass = this.mass + other.mass;
    var impulse = (2 * dvn) / totalMass;

    this.vx -= impulse * other.mass * nx * RESTITUTION;
    this.vy -= impulse * other.mass * ny * RESTITUTION;
    other.vx += impulse * this.mass * nx * RESTITUTION;
    other.vy += impulse * this.mass * ny * RESTITUTION;

    this.rotationSpeed += (Math.random() - 0.5) * 1;
    other.rotationSpeed += (Math.random() - 0.5) * 1;

    // Separate overlap
    var avgSize = (this.width + this.height + other.width + other.height) / 4;
    var minDist = avgSize * 0.7;
    var overlap = minDist - dist + 1;
    if (overlap > 0) {
      this.x += nx * overlap * 0.5;
      this.y += ny * overlap * 0.5;
      other.x -= nx * overlap * 0.5;
      other.y -= ny * overlap * 0.5;
    }
  };

  function startAnimation(engine) {
    // Stop existing loop
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
    
    // Clear container
    container.innerHTML = '';
    molecules = [];

    // Determine style
    // moleculeviewer -> rdkit
    // mol2chemfig -> mol2chemfig
    // pubchem -> mol2chemfig (per user request)
    var style = (engine === 'moleculeviewer') ? 'rdkit' : 'mol2chemfig';
    var svgs = moleculeData[style];
    var types = Object.keys(svgs);
    
    // Shuffle types to ensure variety
    types.sort(() => Math.random() - 0.5);

    // Create molecules
    // User wants ~1.6x previous amount (was 20, so ~32)
    var numMolecules = Math.min(32, types.length);

    for (var i = 0; i < numMolecules; i++) {
      var type = types[i];
      var svg = svgs[type];
      
      // Find a non-overlapping position
      var x, y, attempts = 0;
      var valid = false;
      
      // Temporary molecule to check size
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = svg;
      var tempSvg = tempDiv.querySelector('svg');
      var w = 60, h = 60;
      if (tempSvg) {
         w = parseFloat(tempSvg.getAttribute('width')) * 0.6;
         h = parseFloat(tempSvg.getAttribute('height')) * 0.6;
      }
      
      while (!valid && attempts < 50) {
        x = 5 + Math.random() * (WIDTH - w - 10);
        y = 5 + Math.random() * (HEIGHT - h - 10);
        
        valid = true;
        for (var j = 0; j < molecules.length; j++) {
          var other = molecules[j];
          var dx = (x + w/2) - other.getCenterX();
          var dy = (y + h/2) - other.getCenterY();
          var dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < (w + h + other.width + other.height)/4) {
            valid = false;
            break;
          }
        }
        attempts++;
      }
      
      molecules.push(new Molecule(type, svg, x, y));
    }

    animate();
  }

  function animate() {
    for (var i = 0; i < molecules.length; i++) {
      molecules[i].update();
    }

    for (var j = 0; j < molecules.length; j++) {
      for (var k = j + 1; k < molecules.length; k++) {
        if (molecules[j].collidesWith(molecules[k])) {
          molecules[j].handleCollision(molecules[k]);
        }
      }
    }

    animationId = requestAnimationFrame(animate);
  }

  // Initialize
  chrome.storage.sync.get({
    rendererEngine: 'moleculeviewer'
  }, function(settings) {
    startAnimation(settings.rendererEngine);
  });

  // Listen for changes
  chrome.storage.onChanged.addListener(function(changes, namespace) {
    if (changes.rendererEngine) {
      startAnimation(changes.rendererEngine.newValue);
    }
  });

})();
""" % json.dumps(molecule_data, indent=2)

with open(r'c:\Users\Kapil\Personal\PROJECTS\Chemparser\chem-extension\popup-animation.js', 'w') as f:
    f.write(js_content)

print("Updated popup-animation.js")
